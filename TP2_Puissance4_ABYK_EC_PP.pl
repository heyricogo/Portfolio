
% /brief EtatsGagnants : liste des Ètats gagnants.
etats_gagnants:-
    [[[p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _], [p, _, _, _, _, _]],



    [[_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _], [_, p, _, _, _, _]],



    [[_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _], [_, _, p, _, _, _]],



    [[_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _], [_, _, _, p, _, _]],



    [[_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _], [_, _, _, _, p, _]],



    [[_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p], [_, _, _, _, _, p]],







    [[p, p, p, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, p, p, p, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, p, p, p, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [p, p, p, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, p, p, p, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, p, p, p, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [_, _, _, _, _, _], [p, p, p, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, p, p, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, p, p, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, p, p, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, p_, p, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, p, p, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, p, p, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, p, p, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, p, p, p], [_, _, _, _, _, _], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, p, p, p, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, p, p, p, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, p, p, p], [_, _, _, _, _, _]],



    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, p, p, p, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, p, p, p, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, p, p, p]],







    [[p, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [p, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [p, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [p, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _]],



    [[_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, p, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _]],



    [[_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, p], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, p], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, p], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, p, _, _, _], [_, _, _, p, _, _], [_, _, _, _, p, _], [_, _, _, _, _, p]],



    [[_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [p, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [p, _, _, _, _, _]],



    [[_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, p, _, _, _, _]],



    [[_, _, _, _, _, p], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _], [_, _, _, _, _, _]],

    [[_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, _], [_, _, _, _, _, p], [_, _, _, _, p, _], [_, _, _, p, _, _], [_, _, p, _, _, _]]


    ].


% √©tan initial, la grille est vide au d√©but du jeu

jouer :- tourJoueurJaune([[],[],[],[],[],[],[]]).

% règle de jeu pour tourJoueurJaune

tourJoueurJaune(GrilleDeJeu) :- conditionFinJeu(GrilleDeJeu, JoueurCourrant), affichageGrille(GrilleDeJeu), write(JoueurCourrant), nl, !.
tourJoueurJaune(GrilleDeJeu) :- affichageGrille(GrilleDeJeu), nl, read(Colonne), coupJoueurCourant(GrilleDeJeu, Colonne, j, GrilleApresCoup), tourJoueurRouge(GrilleApresCoup).
tourJoueurRouge(GrilleDeJeu) :- conditionFinJeu(GrilleDeJeu, JoueurCourrant), affichageGrille(GrilleDeJeu), write(JoueurCourrant), nl, !.
tourJoueurRouge(GrilleDeJeu) :- affichageGrille(GrilleDeJeu), nl, selectionnerCoupIA(GrilleDeJeu, Colonne), coupJoueurCourant(GrilleDeJeu, Colonne, r, GrilleApresCoup), tourJoueurJaune(GrilleApresCoup).

% nombre de possibilit√© de pions √† mettre dans la grille de jeu

nombreDePion(N, Liste, []):- longueurListe(Liste, N1), N1 < N.
nombreDePion(N, Liste, P) :- longueurListe(Liste, N1), N2 is N1-N+1, nth1(N2, Liste, P).

% operation pour un joueur

coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 1, P, [[P|Liste1], Liste2, Liste3, Liste4, Liste5, Liste6, Liste7]) :- longueurListe(Liste1, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 2, P, [Liste1, [P|Liste2], Liste3, Liste4, Liste5, Liste6, Liste7]) :- longueurListe(Liste2, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 3, P, [Liste1, Liste2, [P|Liste3], Liste4, Liste5, Liste6, Liste7]) :- longueurListe(Liste3, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 4, P, [Liste1, Liste2, Liste3, [P|Liste4], Liste5, Liste6, Liste7]) :- longueurListe(Liste4, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 5, P, [Liste1, Liste2, Liste3, Liste4, [P|Liste5], Liste6, Liste7]) :- longueurListe(Liste5, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 6, P, [Liste1, Liste2, Liste3, Liste4, Liste5, [P|Liste6], Liste7]) :- longueurListe(Liste6, N), N < 6 .
coupJoueurCourant([Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, Liste7], 7, P, [Liste1, Liste2, Liste3, Liste4, Liste5, Liste6, [P|Liste7]]) :- longueurListe(Liste7, N), N < 6 .


%chaque colonne de jeu est une liste, N est la longueur de chaque liste
% Nous avons 7 colonnes

longueurListe([], 0).
longueurListe([P|Liste], N) :- longueurListe(Liste, N1), N=N1+1.


% affichage de la grille de jeu

affichageGrille(GrilleDeJeu) :- affichage(GrilleDeJeu, 6).
affichage(_, 0).
affichage(GrilleDeJeu, N) :- maplist(nombreDePion(N), GrilleDeJeu, Liste), write(')( '), afficherListe(Liste), N1 is N-1, affichage(GrilleDeJeu, N1).
afficherListe([]) :- nl.
afficherListe([P|Liste]) :- afficherPion(P), afficherListe(Liste).
afficherPion([]) :- write('  )( '), !.
afficherPion(P) :- write(P), write(' )( ').


conditionFinJeu(GrilleDeJeu, JoueurCourrant) :- testAlignementHorizontal(GrilleDeJeu, JoueurCourrant).
conditionFinJeu(GrilleDeJeu, JoueurCourrant) :- testAlignementVertical(GrilleDeJeu, JoueurCourrant).
conditionFinJeu(GrilleDeJeu, JoueurCourrant) :- testGrillePleine(GrilleDeJeu).

%------------------------------------------------------------------------------------------------------------------------------------------------------------------------
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 6).
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 5).
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 4).
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 3).
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 2).
testAlignementHorizontal([_, _, _, Liste4, Liste5, Liste6, Liste7], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste4, Liste5, Liste6, Liste7], JoueurCourrant, 1).

testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 6).
testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 5).
testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 4).
testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 3).
testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 2).
testAlignementHorizontal([_, _, Liste3, Liste4, Liste5, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste3, Liste4, Liste5, Liste6], JoueurCourrant, 1).

testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 6).
testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 5).
testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 4).
testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 3).
testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 2).
testAlignementHorizontal([_, Liste2, Liste3, Liste4, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste2, Liste3, Liste4, Liste5], JoueurCourrant, 1).

testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 6).
testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 5).
testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 4).
testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 3).
testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 2).
testAlignementHorizontal([Liste1, Liste2, Liste3, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionHorizotalement([Liste1, Liste2, Liste3, Liste4], JoueurCourrant, 1).

testAlignementQuatrePionHorizotalement(LigneHorizontale, J, N) :- maplist(nombreDePion(N), LigneHorizontale, Liste), quatrePionAligner(Liste, J).
quatrePionAligner([J, J, J, J], J) :- not(J==[]).

%--------------------------------------------------------------------------------------------------------------------
testAlignementVertical([Liste1, _, _, _, _, _, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste1, JoueurCourrant).
testAlignementVertical([_, Liste2, _, _, _, _, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste2, JoueurCourrant).
testAlignementVertical([_, _, Liste3, _, _, _, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste3, JoueurCourrant).
testAlignementVertical([_, _, _, Liste4, _, _, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste4, JoueurCourrant).
testAlignementVertical([_, _, _, _, Liste5, _, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste5, JoueurCourrant).
testAlignementVertical([_, _, _, _, _, Liste6, _], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste6, JoueurCourrant).
testAlignementVertical([_, _, _, _, _, _, Liste7], JoueurCourrant) :- testAlignementQuatrePionVerticalement(Liste7, JoueurCourrant).

testAlignementQuatrePionVerticalement([JoueurCourrant, JoueurCourrant, JoueurCourrant, JoueurCourrant|Liste], JoueurCourrant).
testAlignementQuatrePionVerticalement([P|Liste], J) :- testAlignementQuatrePionVerticalement(Liste, J).

%------------------------------------------------------------------------------------------------------------------
testGrillePleine([]):- NombreDeColonnesPleines=7.
testGrillePleine([Colonne|ListeColonnes]):- length(Colonne, N), N=6, testGrillePleine(ListeColonnes).



%------------------------------------------------------------------------------------------------------------------

selectionnerCoupIA(GrilleDeJeu, Colonne) :- remplirColonneIA(GrilleDeJeu, Colonne), !.
selectionnerCoupIA(GrilleDeJeu, Colonne) :- remplirLigneIA(GrilleDeJeu, Colonne), !.
selectionnerCoupIA(GrilleDeJeu, Colonne) :- blockerCoupAdversaireIA(GrilleDeJeu, Colonne), !.
selectionnerCoupIA(GrilleDeJeu, Colonne) :-
    listeLegaux_1(GrilleDeJeu, Liste),
    elementListeHazard(Liste, N),
    Colonne is N.



listeLegaux_1([Colonne|ListeColonnes], [1|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_2(ListeColonnes, ListeColonnesLegales).
listeLegaux_1([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_2(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_2([Colonne|ListeColonnes], [2|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_3(ListeColonnes, ListeColonnesLegales).
listeLegaux_2([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_3(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_3([Colonne|ListeColonnes], [3|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_4(ListeColonnes, ListeColonnesLegales).
listeLegaux_3([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_4(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_4([Colonne|ListeColonnes], [4|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_5(ListeColonnes, ListeColonnesLegales).
listeLegaux_4([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_5(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_5([Colonne|ListeColonnes], [5|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_6(ListeColonnes, ListeColonnesLegales).
listeLegaux_5([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_6(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_6([Colonne|ListeColonnes], [6|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6, listeLegaux_7(ListeColonnes, ListeColonnesLegales).
listeLegaux_6([Colonne|ListeColonnes], ListeColonnesLegales):-  listeLegaux_7(ListeColonnes, ListeColonnesLegales), longueurListe(Colonne, N), not(N<6).
listeLegaux_7([Colonne|ListeColonnes], [7|ListeColonnesLegales]):- longueurListe(Colonne, N), N<6.
listeLegaux_7([Colonne|ListeColonnes], ListeColonnesLegales):- longueurListe(Colonne, N), not(N<6).



elementListeHazard([], []):- !.
elementListeHazard(Liste, N) :-
        length(Liste, Longueur),
        random(0, Longueur, Index),
        nth0(Index, Liste, N).


remplirColonneIA(GrilleDeJeu, Colonne) :- coupJoueurCourant(GrilleDeJeu, Colonne, r, GrilleApresCoup), testAlignementVertical(GrilleApresCoup, r).
remplirLigneIA(GrilleDeJeu, Colonne) :- coupJoueurCourant(GrilleDeJeu, Colonne, r, GrilleApresCoup), testAlignementHorizontal(GrilleApresCoup, r).
blockerCoupAdversaireIA(GrilleDeJeu, Colonne) :- coupJoueurCourant(GrilleDeJeu, Colonne, j, GrilleApresCoup), conditionFinJeu(GrilleApresCoup,j).



% /brief trouver_etats_legaux : permet de gÈnÈrer une liste de tous les
% Ètats lÈgaux atteignables ‡ partir de l'Ètat courant.
trouver_etats_legaux(EtatCourant, ListeEtatsLegaux):-
    coupJoueurCourant(EtatCourant, 1, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 2, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 3, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 4, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 5, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 6, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 7, JoueurCourant, EtatSuivant),
    findall(EtatSuivant, coupJoueurCourant(_,_,_,EtatSuivant), ListeEtatsLegaux).



% /brief trouver_numeros_legaux : permet de gÈnÈrer une liste des
% numÈros de tous les coups lÈgaux possibles ‡ partir de l'Ètat courant.
trouver_numeros_legaux(EtatCourant, ListeNumerosLegaux):-
    coupJoueurCourant(EtatCourant, 1, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 2, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 3, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 4, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 5, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 6, JoueurCourant, EtatSuivant),
    coupJoueurCourant(EtatCourant, 7, JoueurCourant, EtatSuivant),
    findall(Numero, coupJoueurCourant(_,Numero,_,_), ListeNumerosLegaux).



% /brief valeur_heuristique_ordi : permet de trouver la valeur
% heuristique des Ètats, ce qui permet ‡ l'ordi de prendre des dÈcisions
% sur les coups qu'il jouera.
% /param EtatCourant : est un ensemble de listes dÈcrivant l'Ètat dont
% on cherche la valeur heuristique.
% /param EtatsGagnants : est une liste comprenant les diffÈrents Ètats
% gagnants possibles.
% /param NumeroCoup : est un entier reprÈsentant le numÈro du coup dont
% on veut trouver la valeur heuristique. Inutile pour cette
% fonction, mais utile pour la fonction decision_ordi, qui utilise
% valeur_heuristique_ordi.
% /param ListeEtatsLegaux : est la liste des Ètats lÈgaux
% atteignables ‡ partir de l'Ètat courant.
% /param ListeNumerosLegaux : est la liste des numÈros des coups lÈgaux,
% dans le mÍme ordre que les Ètats lÈgaux correspondants sont dans ListeEtatsLegaux.
% /value JoueurCourant : le joueur qui joue ce
% coup, dÈcrit par la couleur de ses jetons.
% /value ValMax : est la
% valeur entiËre maximale parmis les Val comparÈs.
% /value ListeVal : est
% la liste des valeurs heuristiques ‡ comparer.
% /value Val : est une
% valeur entiËre reprÈsentant la valeur heuristique d'un Ètat.
% /return Valeur : est une valeur entiËre reprÈsentant la valeur
% heuristique de l'Ètat courant.

% Si l'Ètat est le premier de la liste des Ètats gagnants, on retourne
% sa valeur + 0.
valeur_heuristique_ordi(EtatCourant, [EtatCourant | EtatsGagnants],
                        Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    Valeur is 0, !.

% Si l'Ètat n'est pas le premier de la liste des Ètats gagnants, on fait
% un appel rÈcursif pour voir si c'est le prochain Ètat de cette liste.
valeur_heuristique_ordi(EtatCourant, [E | EtatsGagnants], Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    valeur_heuristique_ordi(EtatCourant, EtatsGagnants, Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux), !.

% Si l'Ètat n'est pas gagnant, on trouve la valeur de tous les
% Ètats suivants possibles.
valeur_heuristique_ordi(EtatCourant, [], Valeur, Compteur, NumeroCoup, [E|ListeEtatsLegaux], [N|ListeNumerosLegaux]):-
    valeur_heuristique_joueur(coupJoueurCourant(EtatCourant, N, JoueurCourant, EtatSuivant), LesEtatsGagnant, Valeur_1, Compteur_1, NumeroCoup,
                              [E|ListeEtatsLegaux], [N|ListeNumerosLegaux]),
    valeur_heuristique_ordi(EtatCourant, [], Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux).

% AprËs avoir trouvÈ la valeur de tous les Ètats suivants, on donne ‡
% l'Ètat courant la valeur la plus haute parmi celles des Ètats suivants
% possibles, car c'est le coup le plus probable du joueur humain jouant
% optimalement (min).
valeur_heuristique_ordi(EtatCourant, [], Valeur, Compteur, NumeroCoup, [], []):-
    findall(Val, valeur_heuristique_joueur(_, _, Val, _, _, _, _), ListeVal),
    plus_grand_element_liste(ValMax, ListeVal),
    Valeur is ValMax + 1,
    Compteur is Compteur_1 + 1, !.

% Si l'Ètat n'est pas gagnant et que le compteur atteint la valeur de 0,
% on ne fait plus d'appel rÈcursif et on retourne simplement la valeur
% de Valeur.
valeur_heuristique_ordi(EtatCourant, [], Valeur, 0, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    Valeur is 1, !.


% /brief valeur_heuristique_joueur : aide valeur_heuristique_ordi ‡
% simuler les coups du joueur humain selon un comportement minpour
% donner une meilleure estimation de la valeur heuristique des Ètats
% /param EtatCourant : est un ensemble de listes dÈcrivant l'Ètat dont
% on cherche la valeur heuristique.
% /param EtatsGagnants : est une liste comprenant les diffÈrents Ètats
% gagnants possibles.
% /param NumeroCoup : est un entier reprÈsentant le numÈro du coup dont
% on veut trouver la valeur heuristique. Inutile pour cette
% fonction, mais utile pour la fonction decision_ordi, qui utilise
% valeur_heuristique_ordi.
% /param ListeEtatsLegaux : est la liste des Ètats lÈgaux
% atteignables ‡ partir de l'Ètat courant.
% /param ListeNumerosLegaux : est la liste des numÈros des coups lÈgaux,
% dans le mÍme ordre que les Ètats lÈgaux correspondants sont dans ListeEtatsLegaux.
% /value JoueurCourant : le joueur qui joue ce coup, dÈcrit par la
% couleur de ses jetons.
% /value ValMin : est la valeur entiËre minimale parmis les Val
% comparÈs.
% /value ListeVal : est la liste des valeurs heuristiques ‡ comparer.
% /value Val : est une valeur entiËre reprÈsentant la valeur heuristique
% d'un Ètat.
% /return Valeur : est une valeur entiËre reprÈsentant la valeur
% heuristique de l'Ètat courant.

% Si l'Ètat est le premier de la liste des Ètats gagnants, on retourne
% sa valeur + 10 pour donner une prioritÈ ÈlevÈe ‡ l'opÈration menant ‡
% cet Ètat, car cette opÈration sera probablement utilisÈe par le
% joueur.
valeur_heuristique_joueur(EtatCourant, [EtatCourant | EtatsGagnants],
                          Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    Valeur is 10, !.

% Si l'Ètat n'est pas le premier de la liste des Ètats gagnants, on fai
% un appel rÈcursif pour voir si c'est le prochain Ètat de cette liste.
valeur_heuristique_joueur(EtatCourant, [E | EtatsGagnants], Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    valeur_heuristique_joueur(EtatCourant, EtatsGagnants, Valeur, Compteur, NumeroCoup), !.

% Si l'Ètat n'est pas gagnant, on trouve la valeur de tous les
% Ètats suivants possibles.
valeur_heuristique_joueur(EtatCourant, [], Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    valeur_heuristique_ordi(coupJoueurCourant(EtatCourant, N, JoueurCourant, EtatSuivant), LesEtatsGagnant, Valeur_1, Compteur_1, NumeroCoup,
                              [E|ListeEtatsLegaux], [N|ListeNumerosLegaux]),
    valeur_heuristique_joueur(EtatCourant, [], Valeur, Compteur, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux).

% AprËs avoir trouvÈ la valeur de tous les Ètats suivant, on donne ‡
% l'Ètat courant la valeur la plus haute parmi celles des Ètats suivants
% possibles, car c'est le coup le plus probable de l'ordinateur jouant
% optimalement (max).
valeur_heuristique_joueur(EtatCourant, [], Valeur, Compteur, NumeroCoup, [], []):-
    findall(Val, valeur_heuristique_joueur(_, _, Val, _, _, _, _), ListeVal),
    plus_petit_element_liste(ValMin, ListeVal),
    Valeur is ValMin + 1,
    Compteur is Compteur_1 + 1, !.

% Si l'Ètat n'est pas gagnant et que le compteur atteint la valeur de 0,
% on ne fait plus d'appel rÈcursif et on retourne simplement la valeur
% de Valeur.
valeur_heuristique_joueur(EtatCourant, [], Valeur, 0, NumeroCoup, ListeEtatsLegaux, ListeNumerosLegaux):-
    Valeur is 1, !.



% /brief plus_petit_element_liste : permet de trouver le plus petit
% ÈlÈment d'une liste.
% /param Liste : est la liste de valeurs entiËres dont on cherche la
% valeur minimale.
% /return ValeurMin : est la valeur entiËre minimale de la liste jusqu'‡
% prÈsent.
plus_petit_element_liste(1000, []):- !.

plus_petit_element_liste(ValeurMin, [L|Liste]):-
    plus_petit_element_liste(ValeurMin_1, Liste),
    ValeurMin is min(L, ValeurMin_1), !.



% /brief plus_grand_element_liste : permet de trouver le plus grand
% ÈlÈment d'une liste.
% /param Liste : est la liste de valeurs entiËres dont on cherche la
% valeur maximale.
% /return ValeurMax : est la valeur entiËre maximale de la liste jusqu'‡
% prÈsent.
plus_grand_element_liste(0, []):- !.

plus_grand_element_liste(ValeurMax, [L|Liste]):-
    plus_grand_element_liste(ValeurMax_1, Liste),
    ValeurMax is max(L, ValeurMax_1), !.


% /brief decision_ordi : permet au joueur ordinateur de prendre des
% dÈcision en ce qui ‡ trait au coup qu'il devrait jouer. L'ordi prendra
% la dÈcision de jouer le coup ayant la valeur heuristique la plus
% basse.
% /param EtatCourant : est l'Ètat ‡ partir duquel on veut prendre la
% dÈcision.
% /param EtatsGagnants : est la liste des Ètats gagnants.
% /param ListeEtatsLegaux : est la liste des Ètats lÈgaux
% atteignables ‡ partir de l'Ètat courant.
% /param ListeNumerosLegaux : est la liste des numÈros des coups lÈgaux,
% dans le mÍme ordre que les Ètats lÈgaux correspondants sont dans
% ListeEtatsLegaux.
% /return : rien.

% S'il n'y a plus d'Ètat lÈgal non traitÈ, on fait une liste de toutes
% les valeurs trouvÈes, on trouve la valeur la plus petite et on joue le
% coup correspondant ‡ cette valeur heuristique.
decision_ordi(EtatCourant, EtatsGagnants, [], []):-
    findall(Val, valeur_heuristique_ordi(_, _, Val, _, _, _, _), ListeVal),
    plus_petit_element_liste(ValMin, ListeVal),
    findall(NumeroCoup, valeur_heuristique_ordi(_,_,ValMin, _, NumeroCoup, _, _), [C|MeilleurCoup]),
    coupJoueurCourant(EtatCourant, C, JoueurCourant, EtatSuivant),
    !.

% S'il reste des Ètats lÈgaux ‡ traiter, on trouve la valeur heuristique
% du prochain Ètat lÈgal en s'assurant d'attribuer cette valeur au bon
% numero de coup, puis on fait un appel rÈcursif ‡ decision_ordi pour
% traiter le reste des Ètats lÈgaux.
decision_ordi(EtatCourant, EtatsGagnants, [E|ListeEtatsLegaux], [N|ListeNumerosLegaux]):-
    valeur_heuristique_ordi(E, EtatsGagnants, Valeur, 5, N, LesEtatsLegaux, LesNumerosLegaux),
    decision_ordi(EtatCourant, EtatsGagnants, ListeEtatsLegaux, ListeNumerosLegaux).
